diff --git a/node_modules/prismarine-chunk/README.md b/node_modules/prismarine-chunk/README.md
index 467d79e..fe363e8 100644
--- a/node_modules/prismarine-chunk/README.md
+++ b/node_modules/prismarine-chunk/README.md
@@ -43,9 +43,25 @@ Install it globally with `npm install minecraft-chunk-dumper -g` then run :
 
 ### bedrock
 
-Run tests in [bedrock-provider](https://github.com/PrismarineJS/bedrock-provider/) (which loads chunks through a client as part of its tests) and copy the generated data from `fixtures/$version/pchunk` into `tests/bedrock_$version`.
+Test data can be generated using the included script:
+```bash
+node tools/generate-bedrock-test-data.mjs <version> <chunkX> <chunkZ> <levelSeed>
+```
+
+Example:
+```bash
+node tools/generate-bedrock-test-data.mjs 1.21.90 -7 10 8403237569561413924
+```
+
+This script will generate test data for different caching and hash configurations in the `test/bedrock_<version>/` directory. 
 
-For the version, copy one chunk column of `level_chunk` without caching, `level_chunk` with caching, `level_chunk CacheMissResponse`, `subchunk` without caching, `subchunk cached` and `subchunk CacheMissResponse` into the test/version folder.
+For the version, keep only one chunk column of test data with the following files:
+- `level_chunk` without caching (one file per hash/no-hash configuration)
+- `level_chunk` with caching (one file per hash/no-hash configuration)
+- `level_chunk CacheMissResponse` (one file per hash/no-hash configuration)
+- `subchunk` without caching (one file per hash/no-hash configuration)
+- `subchunk` with caching (one file per hash/no-hash configuration)
+- `subchunk CacheMissResponse` (only one representative file per hash/no-hash configuration)
 
 Note: bedrock-provider tests network decoding and loading chunks from a save database. The tests in prismarine-chunk test other parts of the chunk API, such as
 setting and getting block light, type, biome, entity and block entity data.
diff --git a/node_modules/prismarine-chunk/src/bedrock/1.18/BiomeSection.js b/node_modules/prismarine-chunk/src/bedrock/1.18/BiomeSection.js
index eb7f79b..c51dff8 100644
--- a/node_modules/prismarine-chunk/src/bedrock/1.18/BiomeSection.js
+++ b/node_modules/prismarine-chunk/src/bedrock/1.18/BiomeSection.js
@@ -41,7 +41,7 @@ class BiomeSection {
     this.biomes.read(buf)
 
     // now read palette
-    if (type === StorageType.Runtime) {
+    if (type === StorageType.Runtime || type === StorageType.NetworkPersistence) {
       // Shift 1 bit to un-zigzag (we cannot be negative)
       const biomePaletteLength = buf.readVarInt() >> 1
       for (let i = 0; i < biomePaletteLength; i++) {
diff --git a/node_modules/prismarine-chunk/src/bedrock/1.18/SubChunk.js b/node_modules/prismarine-chunk/src/bedrock/1.18/SubChunk.js
index 35cd853..a65ff11 100644
--- a/node_modules/prismarine-chunk/src/bedrock/1.18/SubChunk.js
+++ b/node_modules/prismarine-chunk/src/bedrock/1.18/SubChunk.js
@@ -8,8 +8,9 @@ class SubChunk118 extends SubChunk13 {
 
     for (let i = 0; i < paletteSize; i++) {
       const runtimeId = stream.readZigZagVarInt()
-      const block = this.registry.blocksByRuntimeId[runtimeId]
-      this.palette[storageLayer][i] = { stateId: block.stateId, ...block, count: 0 }
+      const block = this.registry.supportFeature('blockHashes') ? this.registry.blocksByRuntimeId[runtimeId] : this.registry.blockStates[runtimeId]
+
+      this.palette[storageLayer][i] = { ...block, stateId: runtimeId, count: 0 }
     }
   }
 
@@ -17,7 +18,7 @@ class SubChunk118 extends SubChunk13 {
     if ((format === StorageType.Runtime) && (bitsPerBlock === 0)) {
       this.palette[storageLayer] = []
       this.blocks[storageLayer] = new PalettedStorage(1)
-      const stateId = stream.readVarInt() >> 1
+      const stateId = stream.readZigZagVarInt()
       this.addToPalette(storageLayer, stateId)
       return
     }
diff --git a/node_modules/prismarine-chunk/src/bedrock/1.3/SubChunk.js b/node_modules/prismarine-chunk/src/bedrock/1.3/SubChunk.js
index 52b233e..4d3ceda 100644
--- a/node_modules/prismarine-chunk/src/bedrock/1.3/SubChunk.js
+++ b/node_modules/prismarine-chunk/src/bedrock/1.3/SubChunk.js
@@ -36,7 +36,7 @@ class SubChunk {
     subChunk.blocks.push(new PalettedStorage(1))
     subChunk.palette.push([])
     // Set zero to be air, Add to the palette
-    subChunk.addToPalette(0, subChunk.registry.blocksByName.air.defaultState, 4096)
+    subChunk.addToPalette(0, subChunk.registry.blocksByName.air.runtime_id ?? subChunk.registry.blocksByName.air.defaultState, 4096)
     return subChunk
   }
 
@@ -56,7 +56,7 @@ class SubChunk {
       case 9:
         storageCount = stream.readByte()
         if (this.subChunkVersion >= 9) {
-          this.y = stream.readByte() // Sub Chunk Index
+          this.y = stream.readInt8() // Sub Chunk Index
         }
         if (storageCount > 2) {
           // This is technically not an error, but not currently aware of any servers
@@ -160,7 +160,7 @@ class SubChunk {
     stream.writeUInt8(this.subChunkVersion)
     stream.writeUInt8(this.blocks.length)
     if (this.subChunkVersion >= 9) { // Caves and cliffs (1.17-1.18)
-      stream.writeUInt8(this.y)
+      stream.writeInt8(this.y)
     }
     for (let l = 0; l < this.blocks.length; l++) {
       if (compact) this.compact(l) // Compact before encoding
@@ -234,7 +234,7 @@ class SubChunk {
   getBlockStateId (l = 0, x, y, z) {
     const blocks = this.blocks[l]
     if (!blocks) {
-      return this.registry.blocksByName.air.defaultState
+      return this.registry.blocksByName.air.runtime_id ?? this.registry.blocksByName.air.defaultState
     }
     return this.palette[l][blocks.get(x, y, z)].stateId
   }
@@ -243,7 +243,7 @@ class SubChunk {
     if (!this.palette[l]) {
       this.palette[l] = []
       this.blocks[l] = new PalettedStorage(4) // Zero initialized
-      this.addToPalette(l, this.registry.blocksByName.air.defaultState, 4096 - 1)
+      this.addToPalette(l, this.registry.blocksByName.air.runtime_id ?? this.registry.blocksByName.air.defaultState, 4096 - 1)
       this.addToPalette(l, stateId, 1)
       this.blocks[l].set(x, y, z, this.palette[l].length - 1)
     } else {
@@ -271,7 +271,7 @@ class SubChunk {
   }
 
   addToPalette (l, stateId, count = 0) {
-    const block = this.registry.blockStates[stateId]
+    const block = this.registry.supportFeature('blockHashes') ? this.registry.blocksByRuntimeId[stateId] : this.registry.blockStates[stateId]
     this.palette[l].push({ stateId, name: block.name, states: block.states, count })
     const minBits = neededBits(this.palette[l].length - 1)
     if (minBits > this.blocks[l].bitsPerBlock) {
diff --git a/node_modules/prismarine-chunk/src/bedrock/common/CommonChunkColumn.js b/node_modules/prismarine-chunk/src/bedrock/common/CommonChunkColumn.js
index 4084d74..74e4728 100644
--- a/node_modules/prismarine-chunk/src/bedrock/common/CommonChunkColumn.js
+++ b/node_modules/prismarine-chunk/src/bedrock/common/CommonChunkColumn.js
@@ -45,7 +45,7 @@ class CommonChunkColumn {
   getBlock (vec4, full = true) {
     const Y = vec4.y >> 4
     const sec = this.sections[this.co + Y]
-    if (!sec) return this.Block.fromStateId(this.registry.blocksByName.air.defaultState, 0)
+    if (!sec) return this.Block.fromStateId(this.registry.blocksByName.air.runtime_id ?? this.registry.blocksByName.air.defaultState, 0)
     const block = sec.getBlock(vec4.l, vec4.x, vec4.y & 0xf, vec4.z, this.getBiomeId(vec4))
     if (full) {
       block.light = sec.blockLight.get(vec4.x, vec4.y & 0xf, vec4.z)
diff --git a/node_modules/prismarine-chunk/src/bedrock/common/Stream.js b/node_modules/prismarine-chunk/src/bedrock/common/Stream.js
index 92e34e2..901114b 100644
--- a/node_modules/prismarine-chunk/src/bedrock/common/Stream.js
+++ b/node_modules/prismarine-chunk/src/bedrock/common/Stream.js
@@ -275,17 +275,22 @@ class ByteStream {
   }
 
   // Varints
-
   writeVarInt (value) {
     this.resizeForWriteIfNeeded(9)
     let offset = 0
-    while (value >= 0x80) {
-      this.buffer[this.writeOffset + offset] = (value & 0x7f) | 0x80
-      value = value >>> 7
-      offset += 1
-    }
-    this.buffer[this.writeOffset + offset] = value
-    this.writeOffset += offset + 1
+
+    do {
+      let tempByte = value & 0x7f
+      value >>>= 7
+
+      if (value !== 0) {
+        tempByte |= 0x80
+      }
+
+      this.buffer[this.writeOffset + offset] = tempByte
+      offset++
+    } while (value !== 0)
+    this.writeOffset += offset
   }
 
   readVarInt () {
